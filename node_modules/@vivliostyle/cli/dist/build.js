"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = exports.getFullConfig = void 0;
const chalk_1 = __importDefault(require("chalk"));
const terminal_link_1 = __importDefault(require("terminal-link"));
const upath_1 = __importDefault(require("upath"));
const browser_1 = require("./browser");
const builder_1 = require("./builder");
const config_1 = require("./config");
const pdf_1 = require("./pdf");
const server_1 = require("./server");
const util_1 = require("./util");
const webbook_1 = require("./webbook");
async function getFullConfig(cliFlags) {
    const loadedConf = config_1.collectVivliostyleConfig(cliFlags);
    const { vivliostyleConfig, vivliostyleConfigPath } = loadedConf;
    const loadedCliFlags = loadedConf.cliFlags;
    const context = vivliostyleConfig ? upath_1.default.dirname(vivliostyleConfigPath) : util_1.cwd;
    const configEntries = [];
    for (const entry of vivliostyleConfig !== null && vivliostyleConfig !== void 0 ? vivliostyleConfig : [vivliostyleConfig]) {
        const config = await config_1.mergeConfig(loadedCliFlags, entry, context);
        checkUnsupportedOutputs(config);
        // check output path not to overwrite source files
        for (const target of config.outputs) {
            builder_1.checkOverwriteViolation(config, target.path, target.format);
        }
        configEntries.push(config);
    }
    return configEntries;
}
exports.getFullConfig = getFullConfig;
async function build(cliFlags) {
    var _a, _b, _c, _d, _e;
    if (cliFlags.bypassedPdfBuilderOption) {
        const option = JSON.parse(cliFlags.bypassedPdfBuilderOption);
        // Host doesn't know browser path inside of container
        option.executableBrowser = browser_1.getExecutableBrowserPath((_a = option.browserType) !== null && _a !== void 0 ? _a : 'chromium');
        util_1.debug('bypassedPdfBuilderOption', option);
        util_1.startLogging();
        await pdf_1.buildPDF(option);
        // Stop remaining stream output and kill process
        util_1.stopLogging();
        server_1.teardownServer();
        return;
    }
    const isInContainer = util_1.checkContainerEnvironment();
    util_1.startLogging('Collecting build config');
    const configEntries = await getFullConfig(cliFlags);
    for (const config of configEntries) {
        // build artifacts
        if (config.manifestPath) {
            await builder_1.compile(config);
            await builder_1.copyAssets(config);
        }
        // generate files
        for (const target of config.outputs) {
            let output = null;
            if (target.format === 'pdf') {
                if (!isInContainer && target.renderMode === 'docker') {
                    output = await pdf_1.buildPDFWithContainer({
                        ...config,
                        input: ((_c = (_b = config.manifestPath) !== null && _b !== void 0 ? _b : config.webbookEntryPath) !== null && _c !== void 0 ? _c : config.epubOpfPath),
                        target,
                    });
                }
                else {
                    output = await pdf_1.buildPDF({
                        ...config,
                        input: ((_e = (_d = config.manifestPath) !== null && _d !== void 0 ? _d : config.webbookEntryPath) !== null && _e !== void 0 ? _e : config.epubOpfPath),
                        target,
                    });
                }
            }
            else if (target.format === 'webpub') {
                if (!config.manifestPath) {
                    continue;
                }
                output = await webbook_1.exportWebPublication({
                    ...config,
                    input: config.workspaceDir,
                    output: target.path,
                });
            }
            if (output) {
                const formattedOutput = chalk_1.default.bold.green(upath_1.default.relative(util_1.cwd, output));
                util_1.log(`\n${terminal_link_1.default(formattedOutput, 'file://' + output, {
                    fallback: () => formattedOutput,
                })} has been created.`);
            }
        }
        server_1.teardownServer();
    }
    util_1.stopLogging('Built successfully.', 'ðŸŽ‰');
}
exports.build = build;
function checkUnsupportedOutputs({ webbookEntryPath, epubOpfPath, outputs, }) {
    if (webbookEntryPath && outputs.some((t) => t.format === 'webpub')) {
        throw new Error('Exporting webpub format from single HTML input is not supported.');
    }
    else if (epubOpfPath && outputs.some((t) => t.format === 'webpub')) {
        throw new Error('Exporting webpub format from EPUB or OPF file is not supported.');
    }
}
//# sourceMappingURL=build.js.map