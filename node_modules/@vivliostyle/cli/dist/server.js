"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getViewerFullUrl = exports.teardownServer = exports.prepareServer = void 0;
const http_1 = __importDefault(require("http"));
const resolve_pkg_1 = __importDefault(require("resolve-pkg"));
const serve_handler_1 = __importDefault(require("serve-handler"));
const upath_1 = __importDefault(require("upath"));
const url_1 = require("url");
const util_1 = require("./util");
let _viewerServer;
let _sourceServer;
async function prepareServer(option) {
    const viewerUrl = await (option.viewer && util_1.isUrlString(option.viewer)
        ? new url_1.URL(option.viewer)
        : option.httpServer
            ? (async () => {
                const viewerRoot = resolve_pkg_1.default('@vivliostyle/viewer', {
                    cwd: __dirname,
                });
                _viewerServer = _viewerServer || (await launchServer(viewerRoot));
                const viewerUrl = new url_1.URL('http://localhost');
                viewerUrl.port = `${_viewerServer.port}`;
                viewerUrl.pathname = '/lib/index.html';
                return viewerUrl;
            })()
            : (() => {
                const viewerUrl = new url_1.URL('file://');
                viewerUrl.pathname = upath_1.default.join(resolve_pkg_1.default('@vivliostyle/viewer', { cwd: __dirname }), 'lib/index.html');
                return viewerUrl;
            })());
    const sourceUrl = await (util_1.isUrlString(option.input)
        ? new url_1.URL(option.input)
        : option.httpServer ||
            // Use http server because http viewer cannot access to file protocol
            (option.viewer && /^https?:/i.test(option.viewer))
            ? (async () => {
                _sourceServer =
                    _sourceServer || (await launchServer(option.workspaceDir));
                const sourceUrl = new url_1.URL('http://localhost');
                sourceUrl.port = `${_sourceServer.port}`;
                sourceUrl.pathname = upath_1.default.relative(option.workspaceDir, option.input);
                return sourceUrl;
            })()
            : url_1.pathToFileURL(option.input));
    return {
        viewerFullUrl: getViewerFullUrl(option, {
            viewerUrl,
            sourceUrl,
        }),
    };
}
exports.prepareServer = prepareServer;
function teardownServer() {
    if (_viewerServer) {
        _viewerServer.server.close();
        _viewerServer = undefined;
    }
    if (_sourceServer) {
        _sourceServer.server.close();
        _sourceServer = undefined;
    }
}
exports.teardownServer = teardownServer;
function getViewerFullUrl({ size, cropMarks, bleed, cropOffset, css, style, userStyle, singleDoc, quick, }, { viewerUrl, sourceUrl }) {
    const pageSizeValue = size && ('format' in size ? size.format : `${size.width} ${size.height}`);
    function escapeParam(url) {
        return url.replace(/&/g, '%26');
    }
    let viewerParams = sourceUrl.href === 'data:,'
        ? '' // open Viewer start page
        : `src=${escapeParam(sourceUrl.href)}`;
    viewerParams += `&bookMode=${!singleDoc}&renderAllPages=${!quick}`;
    if (style) {
        viewerParams += `&style=${escapeParam(style)}`;
    }
    if (userStyle) {
        viewerParams += `&userStyle=${escapeParam(userStyle)}`;
    }
    if (pageSizeValue || cropMarks || bleed || cropOffset || css) {
        let pageStyle = '@page{';
        if (pageSizeValue) {
            pageStyle += `size:${pageSizeValue};`;
        }
        if (cropMarks) {
            pageStyle += `marks:crop cross;`;
        }
        if (bleed || cropMarks) {
            pageStyle += `bleed:${bleed !== null && bleed !== void 0 ? bleed : '3mm'};`;
        }
        if (cropOffset) {
            pageStyle += `crop-offset:${cropOffset};`;
        }
        pageStyle += '}';
        // The pageStyle settings are put between the `/*<viewer>*/` and `/*</viewer>*/`
        // in the `&style=data:,â€¦` viewer parameter so that they are reflected in the
        // Settings menu of the Viewer. Also the custom CSS code is appended after the
        // `/*</viewer>*/` so that it is shown in the Edit CSS box in the Settings menu.
        viewerParams += `&style=data:,/*<viewer>*/${encodeURIComponent(pageStyle)}/*</viewer>*/${encodeURIComponent(css !== null && css !== void 0 ? css : '')}`;
    }
    return `${viewerUrl.href}#${viewerParams}`;
}
exports.getViewerFullUrl = getViewerFullUrl;
function startEndpoint(root) {
    const serve = (req, res) => serve_handler_1.default(req, res, {
        public: root,
        cleanUrls: false,
        directoryListing: false,
        headers: [
            {
                source: '**',
                headers: [
                    {
                        key: 'access-control-allow-headers',
                        value: 'Origin, X-Requested-With, Content-Type, Accept, Range',
                    },
                    {
                        key: 'access-control-allow-origin',
                        value: '*',
                    },
                    {
                        key: 'cache-control',
                        value: 'no-cache, no-store, must-revalidate',
                    },
                ],
            },
        ],
    });
    return http_1.default.createServer(serve);
}
async function launchServer(root) {
    const port = await util_1.findAvailablePort();
    util_1.debug(`Launching server... root: ${root} port: ${port}`);
    const server = startEndpoint(root);
    return await new Promise((resolve) => {
        server.listen(port, 'localhost', () => {
            util_1.beforeExitHandlers.push(() => {
                server.close();
            });
            resolve({ server, port });
        });
    });
}
//# sourceMappingURL=server.js.map