"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkContainerEnvironment = exports.findAvailablePort = exports.isUrlString = exports.pathStartsWith = exports.pathEquals = exports.touchTmpFile = exports.useTmpDirectory = exports.inflateZip = exports.statFileSync = exports.readJSON = exports.filterRelevantAjvErrors = exports.gracefulError = exports.DetailError = exports.logInfo = exports.logWarn = exports.logError = exports.logSuccess = exports.logUpdate = exports.log = exports.stopLogging = exports.startLogging = exports.beforeExitHandlers = exports.cwd = exports.debug = void 0;
const chalk_1 = __importDefault(require("chalk"));
const debug_1 = __importDefault(require("debug"));
const fs_1 = __importDefault(require("fs"));
const node_stream_zip_1 = __importDefault(require("node-stream-zip"));
const ora_1 = __importDefault(require("ora"));
const portfinder_1 = __importDefault(require("portfinder"));
const shelljs_1 = __importDefault(require("shelljs"));
const tmp_1 = __importDefault(require("tmp"));
const upath_1 = __importDefault(require("upath"));
const util_1 = __importDefault(require("util"));
exports.debug = debug_1.default('vs-cli');
exports.cwd = upath_1.default.normalize(process.cwd());
const ora = ora_1.default({
    color: 'blue',
    spinner: 'circle',
    // Prevent stream output in docker so that not to spawn process
    // In other environment, check TTY context
    isEnabled: checkContainerEnvironment() ? false : undefined,
});
exports.beforeExitHandlers = [];
const exitSignals = ['exit', 'SIGINT', 'SIGTERM', 'SIGHUP'];
exitSignals.forEach((sig) => {
    process.on(sig, (code) => {
        var _a;
        while (exports.beforeExitHandlers.length) {
            try {
                (_a = exports.beforeExitHandlers.shift()) === null || _a === void 0 ? void 0 : _a();
            }
            catch (e) {
                // NOOP
            }
        }
        process.exit(code);
    });
});
function startLogging(text) {
    // If text is not set, erase previous log with space character
    ora.start(text !== null && text !== void 0 ? text : ' ');
}
exports.startLogging = startLogging;
function stopLogging(text, symbol) {
    if (!text) {
        ora.stop();
        return;
    }
    ora.stopAndPersist({ text, symbol });
}
exports.stopLogging = stopLogging;
function log(...obj) {
    console.log(...obj);
}
exports.log = log;
function logUpdate(...obj) {
    if (ora.isSpinning) {
        ora.text = obj.join(' ');
    }
    else {
        ora.info(obj.join(' '));
    }
}
exports.logUpdate = logUpdate;
function logSuccess(...obj) {
    ora.succeed(obj.join(' '));
}
exports.logSuccess = logSuccess;
function logError(...obj) {
    ora.fail(obj.join(' '));
}
exports.logError = logError;
function logWarn(...obj) {
    ora.warn(obj.join(' '));
}
exports.logWarn = logWarn;
function logInfo(...obj) {
    ora.info(obj.join(' '));
}
exports.logInfo = logInfo;
class DetailError extends Error {
    constructor(message, detail) {
        super(message);
        this.detail = detail;
    }
}
exports.DetailError = DetailError;
function gracefulError(err) {
    const message = err instanceof DetailError
        ? `${chalk_1.default.red.bold('Error:')} ${err.message}\n${err.detail}`
        : err.stack
            ? err.stack.replace(/^Error:/, chalk_1.default.red.bold('Error:'))
            : `${chalk_1.default.red.bold('Error:')} ${err.message}`;
    if (ora.isSpinning) {
        ora.fail(message);
    }
    else {
        console.error(message);
    }
    console.log(chalk_1.default.gray(`
If you think this is a bug, please report at https://github.com/vivliostyle/vivliostyle-cli/issues`));
    process.exit(1);
}
exports.gracefulError = gracefulError;
// Filter errors for human readability
// ref. https://github.com/atlassian/better-ajv-errors/issues/76
function filterRelevantAjvErrors(allErrors) {
    function split(items, splitFn) {
        return [items.filter(splitFn), items.filter((error) => !splitFn(error))];
    }
    function removeShadowingErrors(singleErrors, metaErrors) {
        return singleErrors.filter((error) => {
            if (metaErrors.some((metaError) => error.dataPath.startsWith(metaError.dataPath))) {
                return !singleErrors.some((otherError) => otherError.dataPath.startsWith(error.dataPath) &&
                    otherError.dataPath.length > error.dataPath.length);
            }
            else {
                return true;
            }
        });
    }
    function mergeTypeErrorsByPath(typeErrors) {
        const typeErrorsByPath = typeErrors.reduce((acc, error) => {
            var _a;
            const key = error.dataPath;
            return {
                ...acc,
                [key]: [...((_a = acc[key]) !== null && _a !== void 0 ? _a : []), error],
            };
        }, {});
        return Object.values(typeErrorsByPath).map(mergeTypeErrors);
        function mergeTypeErrors(typeErrors) {
            const params = {
                type: typeErrors.map((error) => error.params.type).join(','),
            };
            return {
                ...typeErrors[0],
                params,
            };
        }
    }
    const META_SCHEMA_KEYWORDS = Object.freeze(['anyOf', 'allOf', 'oneOf']);
    // Split the meta errors from what I call "single errors" (the real errors)
    const [metaErrors, singleErrors] = split(allErrors, (error) => META_SCHEMA_KEYWORDS.includes(error.keyword));
    // Filter out the single errors we want to show
    const nonShadowedSingleErrors = removeShadowingErrors(singleErrors, metaErrors);
    // We're handling type errors differently, split them out
    const [typeErrors, nonTypeErrors] = split(nonShadowedSingleErrors, (error) => error.keyword === 'type');
    // Filter out the type errors that already have other errors as well.
    // For example when setting `logLevel: 4`, we don't want to see the error specifying that logLevel should be a string,
    // if the other error already specified that it should be one of the enum values.
    const nonShadowingTypeErrors = typeErrors.filter((typeError) => !nonTypeErrors.some((nonTypeError) => nonTypeError.dataPath === typeError.dataPath));
    const typeErrorsMerged = mergeTypeErrorsByPath(nonShadowingTypeErrors);
    return [...nonTypeErrors, ...typeErrorsMerged];
}
exports.filterRelevantAjvErrors = filterRelevantAjvErrors;
function readJSON(path) {
    try {
        return JSON.parse(fs_1.default.readFileSync(path, 'utf8'));
    }
    catch (err) {
        return undefined;
    }
}
exports.readJSON = readJSON;
function statFileSync(filePath) {
    try {
        return fs_1.default.statSync(filePath);
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            throw new Error(`Specified input doesn't exists: ${filePath}`);
        }
        throw err;
    }
}
exports.statFileSync = statFileSync;
async function inflateZip(filePath, dest) {
    return await new Promise((res, rej) => {
        try {
            const zip = new node_stream_zip_1.default({
                file: filePath,
                storeEntries: true,
            });
            zip.on('error', (err) => {
                rej(err);
            });
            zip.on('ready', async () => {
                await util_1.default.promisify(zip.extract)(null, dest);
                await util_1.default.promisify(zip.close)();
                exports.debug(`Unzipped ${filePath} to ${dest}`);
                res();
            });
        }
        catch (err) {
            rej(err);
        }
    });
}
exports.inflateZip = inflateZip;
function useTmpDirectory() {
    return new Promise((res, rej) => {
        tmp_1.default.dir({ unsafeCleanup: true }, (err, path, clear) => {
            if (err) {
                return rej(err);
            }
            exports.debug(`Created the temporary directory: ${path}`);
            const callback = () => {
                // clear function doesn't work well?
                // clear();
                shelljs_1.default.rm('-rf', path);
                exports.debug(`Removed the temporary directory: ${path}`);
            };
            exports.beforeExitHandlers.push(callback);
            res([path, callback]);
        });
    });
}
exports.useTmpDirectory = useTmpDirectory;
async function touchTmpFile(path) {
    shelljs_1.default.touch(path);
    exports.debug(`Created the temporary file: ${path}`);
    const callback = () => {
        shelljs_1.default.rm('-f', path);
        exports.debug(`Removed the temporary file: ${path}`);
    };
    exports.beforeExitHandlers.push(callback);
    return callback;
}
exports.touchTmpFile = touchTmpFile;
function pathEquals(path1, path2) {
    return upath_1.default.relative(path1, path2) === '';
}
exports.pathEquals = pathEquals;
function pathStartsWith(path1, path2) {
    return !upath_1.default.relative(path2, path1).startsWith('..');
}
exports.pathStartsWith = pathStartsWith;
function isUrlString(str) {
    return /^(https?|file|data):/i.test(str);
}
exports.isUrlString = isUrlString;
function findAvailablePort() {
    portfinder_1.default.basePort = 13000;
    return portfinder_1.default.getPortPromise();
}
exports.findAvailablePort = findAvailablePort;
function checkContainerEnvironment() {
    return fs_1.default.existsSync('/opt/vivliostyle-cli/.vs-cli-version');
}
exports.checkContainerEnvironment = checkContainerEnvironment;
//# sourceMappingURL=util.js.map