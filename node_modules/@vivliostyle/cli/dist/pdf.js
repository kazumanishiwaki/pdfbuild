"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPDF = exports.buildPDFWithContainer = void 0;
const chalk_1 = __importDefault(require("chalk"));
const shelljs_1 = __importDefault(require("shelljs"));
const terminal_link_1 = __importDefault(require("terminal-link"));
const upath_1 = __importDefault(require("upath"));
const url_1 = require("url");
const browser_1 = require("./browser");
const container_1 = require("./container");
const postprocess_1 = require("./postprocess");
const server_1 = require("./server");
const util_1 = require("./util");
async function buildPDFWithContainer(option) {
    const bypassedOption = {
        ...option,
        input: container_1.toContainerPath(option.input),
        target: {
            ...option.target,
            path: container_1.toContainerPath(option.target.path),
        },
        entryContextDir: container_1.toContainerPath(option.entryContextDir),
        workspaceDir: container_1.toContainerPath(option.workspaceDir),
        customStyle: option.customStyle && container_1.toContainerPath(option.customStyle),
        customUserStyle: option.customUserStyle && container_1.toContainerPath(option.customUserStyle),
        sandbox: false,
    };
    await container_1.runContainer({
        image: option.image,
        userVolumeArgs: container_1.collectVolumeArgs([
            option.workspaceDir,
            upath_1.default.dirname(option.target.path),
        ]),
        commandArgs: [
            'build',
            '--bypassed-pdf-builder-option',
            JSON.stringify(bypassedOption),
        ],
    });
    return option.target.path;
}
exports.buildPDFWithContainer = buildPDFWithContainer;
async function buildPDF({ input, target, workspaceDir, size, cropMarks, bleed, cropOffset, css, customStyle, customUserStyle, singleDoc, executableBrowser, browserType, image, sandbox, verbose, timeout, entryContextDir, entries, httpServer, viewer, }) {
    const isInContainer = util_1.checkContainerEnvironment();
    util_1.logUpdate(`Launching build environment`);
    const { viewerFullUrl } = await server_1.prepareServer({
        input,
        workspaceDir,
        httpServer,
        viewer,
        size,
        cropMarks,
        bleed,
        cropOffset,
        css,
        style: customStyle,
        userStyle: customUserStyle,
        singleDoc,
        quick: false,
    });
    util_1.debug('viewerFullUrl', viewerFullUrl);
    util_1.debug(`Executing browser path: ${executableBrowser}`);
    if (!browser_1.checkBrowserAvailability(executableBrowser)) {
        if (browser_1.isPlaywrightExecutable(executableBrowser)) {
            // The browser isn't downloaded first time starting CLI so try to download it
            await browser_1.downloadBrowser(browserType);
        }
        else {
            // executableBrowser seems to be specified explicitly
            throw new Error(`Cannot find the browser. Please check the executable browser path: ${executableBrowser}`);
        }
    }
    const browser = await browser_1.launchBrowser({
        browserType,
        executablePath: executableBrowser,
        headless: true,
        noSandbox: !sandbox,
        disableWebSecurity: !viewer,
        disableDevShmUsage: isInContainer,
    });
    const browserName = browser_1.getFullBrowserName(browserType);
    const browserVersion = `${browserName}/${await browser.version()}`;
    util_1.debug(chalk_1.default.green('success'), `browserVersion=${browserVersion}`);
    util_1.logUpdate('Building pages');
    const page = await browser.newPage({
        // This viewport size important to detect headless environment in Vivliostyle viewer
        // https://github.com/vivliostyle/vivliostyle.js/blob/73bcf323adcad80126b0175630609451ccd09d8a/packages/core/src/vivliostyle/vgen.ts#L2489-L2500
        viewport: {
            width: 800,
            height: 600,
        },
    });
    page.on('pageerror', (error) => {
        util_1.logError(chalk_1.default.red(error.message));
    });
    page.on('console', (msg) => {
        var _a;
        switch (msg.type()) {
            case 'error':
                if (/\/vivliostyle-viewer\.js$/.test((_a = msg.location().url) !== null && _a !== void 0 ? _a : '')) {
                    util_1.logError(msg.text());
                    throw msg.text();
                }
                return;
            case 'debug':
                if (/time slice/.test(msg.text())) {
                    return;
                }
                break;
        }
        if (!verbose) {
            return;
        }
        if (msg.type() === 'error') {
            util_1.logError(msg.text());
        }
        else {
            util_1.logInfo(msg.text());
        }
    });
    let lastEntry;
    function stringifyEntry(entry) {
        const formattedSourcePath = chalk_1.default.bold.cyan(upath_1.default.relative(entryContextDir, entry.source));
        return `${terminal_link_1.default(formattedSourcePath, 'file://' + entry.source, {
            fallback: () => formattedSourcePath,
        })} ${entry.title ? chalk_1.default.gray(entry.title) : ''}`;
    }
    function handleEntry(response) {
        const entry = entries.find((entry) => {
            if (!('source' in entry)) {
                return false;
            }
            const url = new url_1.URL(response.url());
            return url.protocol === 'file:'
                ? util_1.pathEquals(entry.target, url.pathname)
                : util_1.pathEquals(upath_1.default.relative(workspaceDir, entry.target), url.pathname.substring(1));
        });
        if (entry) {
            if (!lastEntry) {
                lastEntry = entry;
                return util_1.logUpdate(stringifyEntry(entry));
            }
            util_1.logSuccess(stringifyEntry(lastEntry));
            util_1.startLogging(stringifyEntry(entry));
            lastEntry = entry;
        }
    }
    page.on('response', (response) => {
        util_1.debug(chalk_1.default.gray('viewer:response'), chalk_1.default.green(response.status().toString()), response.url());
        handleEntry(response);
        if (300 > response.status() && 200 <= response.status())
            return;
        // file protocol doesn't have status code
        if (response.url().startsWith('file://') && response.ok())
            return;
        util_1.logError(chalk_1.default.red(`${response.status()}`, response.url()));
        util_1.startLogging();
        // debug(chalk.red(`${response.status()}`, response.url()));
    });
    let remainTime = timeout;
    const startTime = Date.now();
    await page.setDefaultTimeout(timeout);
    await page.goto(viewerFullUrl, { waitUntil: 'networkidle' });
    await page.waitForFunction(
    /* istanbul ignore next */ () => !!window.coreViewer);
    await page.emulateMedia({ media: 'print' });
    await page.waitForFunction(
    /* istanbul ignore next */
    () => window.coreViewer.readyState === 'complete', undefined, { polling: 1000 });
    if (lastEntry) {
        util_1.logSuccess(stringifyEntry(lastEntry));
    }
    const pageProgression = await page.evaluate(
    /* istanbul ignore next */ () => {
        var _a;
        return ((_a = document
            .querySelector('#vivliostyle-viewer-viewport')) === null || _a === void 0 ? void 0 : _a.getAttribute('data-vivliostyle-page-progression')) === 'rtl'
            ? 'rtl'
            : 'ltr';
    });
    const viewerCoreVersion = await page.evaluate(
    /* istanbul ignore next */ () => {
        var _a, _b;
        return (_b = (_a = document
            .querySelector('#vivliostyle-menu_settings .version')) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.replace(/^.*?: (\d[-+.\w]+).*$/, '$1');
    });
    const metadata = await loadMetadata(page);
    const toc = await loadTOC(page);
    const pageSizeData = await loadPageSizeData(page);
    remainTime -= Date.now() - startTime;
    if (remainTime <= 0) {
        throw new Error('Typesetting process timed out');
    }
    util_1.debug('Remaining timeout:', remainTime);
    util_1.logUpdate('Building PDF');
    const pdf = await page.pdf({
        margin: {
            top: 0,
            bottom: 0,
            right: 0,
            left: 0,
        },
        printBackground: true,
        preferCSSPageSize: true,
        // timeout: remainTime,
    });
    await browser.close();
    util_1.logUpdate('Processing PDF');
    shelljs_1.default.mkdir('-p', upath_1.default.dirname(target.path));
    const post = await postprocess_1.PostProcess.load(pdf);
    await post.metadata(metadata, {
        pageProgression,
        browserVersion,
        viewerCoreVersion,
        // If custom viewer is set and its version info is not available,
        // there is no guarantee that the default creator option is correct.
        disableCreatorOption: !!viewer && !viewerCoreVersion,
    });
    await post.toc(toc);
    await post.setPageBoxes(pageSizeData);
    await post.save(target.path, {
        preflight: target.preflight,
        preflightOption: target.preflightOption,
        image,
    });
    return target.path;
}
exports.buildPDF = buildPDF;
async function loadMetadata(page) {
    return page.evaluate(
    /* istanbul ignore next */ () => window.coreViewer.getMetadata());
}
// Show and hide the TOC in order to read its contents.
// Chromium needs to see the TOC links in the DOM to add
// the PDF destinations used during postprocessing.
async function loadTOC(page) {
    return page.evaluate(
    /* istanbul ignore next */ () => new Promise((resolve) => {
        function listener(payload) {
            if (payload.a !== 'toc') {
                return;
            }
            window.coreViewer.removeListener('done', listener);
            window.coreViewer.showTOC(false);
            resolve(window.coreViewer.getTOC());
        }
        window.coreViewer.addListener('done', listener);
        window.coreViewer.showTOC(true);
    }));
}
async function loadPageSizeData(page) {
    return page.evaluate(
    /* istanbul ignore next */ () => {
        const sizeData = [];
        const pageContainers = document.querySelectorAll('#vivliostyle-viewer-viewport > div > div > div[data-vivliostyle-page-container]');
        for (const pageContainer of pageContainers) {
            const bleedBox = pageContainer.querySelector('div[data-vivliostyle-bleed-box]');
            sizeData.push({
                mediaWidth: parseFloat(pageContainer.style.width) * 0.75,
                mediaHeight: parseFloat(pageContainer.style.height) * 0.75,
                bleedOffset: parseFloat(bleedBox === null || bleedBox === void 0 ? void 0 : bleedBox.style.left) * 0.75,
                bleedSize: parseFloat(bleedBox === null || bleedBox === void 0 ? void 0 : bleedBox.style.paddingLeft) * 0.75,
            });
        }
        return sizeData;
    });
}
//# sourceMappingURL=pdf.js.map